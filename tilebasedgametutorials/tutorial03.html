<!DOCTYPE HTML>
<!---------------------------------------------->
<!-- tutorial03.html. Frank Poth. 04/22/2015. -->
<!---------------------------------------------->

<!-- Complex Game Loop. -->

<!-- HTML. -->
<html>
	<!-- Head. -->
	<head>
		<!-- Link. -->
		<link href="tilebasedgametutorials.css" rel="stylesheet" type="text/css">
		<!-- Meta. -->
		<meta content="width=device-width" name="viewport">
		<!-- Title. -->
		<title>Tile Based Game Tutorials | Tutorial03</title>
	</head>

	<!-- Body. -->
	<body>
		<!-- Header. -->
		<div id="header">
			<h2>Tile Based Game Tutorials</h2>
		</div>
		<!-- Content. -->
		<div id="content">
			<h2> Complex Game Loop </h2>
			<p>
				So, you might compare this to the last example and see that they are exactly the same. Well, they do the same thing but they each do it differently. The performance differences are only noticeable when run on different processors. While the previous example will render each and every frame of animation quickly or slowly, this example sacrifices frames for constant time updates to the game logic. Sacrifice never sounds like the best option, but you are gaining something important in the process.
			</p>
			<canvas class="Canvas" id="display">
				canvas
			</canvas>
			<p>
				Look and feel are two words often used to describe the playability of a game. Neither of these examples really have a "feel" because you can't interact with them, but imagine you were playing a platforming game that incorporated a degree of skill in controlling the player. You get used to the "feel" of the controls and you time your button presses accordingly. If the feel of your game changes from device to device, controlling the player will feel clumsy. The user will never be able to build a muscle memory and will spend more time focusing on controlling the player than enjoying the game. The way to fix this is to make sure your game updates at a constant rate.
			</p>
			<p>
				Even though your browser can't always update the display at the exact instance you tell it to, you can feel pretty safe that your game will update at a good solid speed on a standard processor. 60 frames per second is about 16.7 milliseconds. As long as your game is updating on a timer and your code isn't overburdening the processor, you will maintain the feel of your game.
			</p>
			<p>
				The look of your game is another story. As for these examples, the look will be mostly dependent on the capabilities of your platform because requestAnimationFrame runs at the speed best fit to your device. To make up for the potential loss of frames on slow devices, this game loop uses something called interpolation. It's a simple concept, really.
			</p>
			<p>
				Say you have two points on a linear graph of time. The first point occurs at time = 0 and the second point occurs at time = 1. If requestAnimationFrame decides to draw right between those two points at time = 0.5, then you don't want to draw your player exactly at either point because it won't accurately reflect the passage of time and it will make your animation look jumpy. Instead, you want to interpolate between the two points at the correct time step, which is 0.5. This will put your player at the right place at the right time when your frame is rendered, and you always want to be in the right place at the right time.
			</p>
			<p>
				The game loop is set up to never allow the time step to be greater than 1, so interpolation will never overshoot the second point. This code was taken from inside the game loop:
			</p>
			<pre class="Math">current_time = Date.now();
elapsed_time = current_time - last_time;
last_time = current_time;

accumulated_time += elapsed_time;

while (accumulated_time >= interval_) {
	accumulated_time -= interval_;
	update();
}

draw(accumulated_time / interval_);//That's the time step ratio.</pre>
			<p>
				Let's say that more time passes between requestAnimationFrame events than your desired update interval allows. This amount of extra time is stored in accumulated_time and then a while loop calls your update function for every time it was missed while requestAnimationFrame was waiting. This gets you up to your most recent possible update, but you might still have some time to cover. So you pass the time step ratio to your draw function and it places your player where he should be between the last update and the current update.
			</p>
			<p>
				In this example, the most recent update is never drawn. The reason for this is that interpolation must happen between two known points in order to work accurately when collision is a factor. You could predict the next point using the player's movement speed added to his current location, but what happens if the predicted point is in a wall? Then you would see your player overlapping a wall when the frame is rendered. To avoid this you have to stop predicting the future and actually know it.
			</p>
			<p>
				Well, you can't know the future so just avoid it all together by rendering one update before the current update and using the current update as your predicted point. The user won't know the difference and your player won't be drawn in a place he should never be.
			</p>
			<p>
				Even though it's a little extra overhead to keep track of the current and last positions of the player, the constant update speed is a good thing to have when your platform could be anything from a tablet to a souped up desktop computer, so I'll be using this code to update the rest of the examples in the series.
			</p>
			<br>
			<a id="left_link" href="tutorial02.html">Tutorial02</a>
			<a id="center_link" href="index.html">Index</a>
			<a id="right_link" href="tutorial04.html">Tutorial04</a>
		</div>
		<!-- This has to be placed outside of the content div because it needs to be absolutely positioned inside the body element and the content div has position:relative. -->
		<p class="Output" id="output">
			output
		</p>
		<!-- Footer. -->
		<div id="footer">
			<a href="https://github.com/userpoth/tilebasedgametutorials">GitHub Repository</a>
		</div>
		<!-- Script. -->
		<script src="tutorial03.js" type="text/javascript"></script>
	</body>
</html>