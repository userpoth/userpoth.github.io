<!DOCTYPE HTML>
<!--------------------------------------------->
<!-- collision.html. Frank Poth. 05/01/2015. -->
<!--------------------------------------------->

<!-- This example can show you the way, the truth and the light about how to implement tile based collision detection and response. -->
<!-- Look at you reading the comments in the source code! That's how you learn stuff! -->

<!-- HTML -->
<html>
	<!-- Head. -->
	<head>
		<!-- Links. -->
		<link href="../tilebasedgametutorials.css" rel="stylesheet" type="text/css">

		<!-- Meta. -->
		<meta content="Example with easy access source code on tile based collision detection and response in HTML5 and JavaScript (showing square tiles and platforms)!" name="description">
		<meta content="width=device-width" name="viewport">

		<!-- Title. -->
		<title>Collision</title>
	</head>

	<!-- Body. -->
	<body>
		<!-- Header. -->
		<div id="header">
			<h2>Tile Based Game Tutorials</h2>
		</div>

		<!-- Content. -->
		<div id="content">
			<h2>Collision With Composite Tiles</h2>
			<p>
				Are you excited to read about tile collision? Well, don't answer until you try the example because you might not like what you see:
			</p>
			<canvas class="Canvas" id="display"></canvas>
			<p>
				Did you spot the glitch? I'm sure you did, it's not hard to spot. The red square gets caught on juxtaposed solid tiles. But hear me out now, because what you're seeing is expected behavior, I sabotaged the level. That's right. Sabotage. Let me explain:
			</p>
			<p>
				This isn't a traditional approach to tile based collision. This approach has three steps and is highly modular in nature. The three steps are: detecting the tile values the red square is colliding with, sending the values and locations of the tile spaces in question to a collision function lookup table which identifies the unique collision tile the red square is colliding with, and finally resolving collision between the red square and the tile one side at a time.
			</p>
			<p>
				That was hard to follow. Before I explain the glitch let me elaborate on the process a little more. Each corner of the red square is in a tile space. Say that the bottom left corner of the red square is in a tile space which is occupied by a platform tile. What should we do? Well, first we have to detect the collision:
			</p>
			<pre class="Math">/* First get the row and column of the bottom left corner of the object. */
var bottom = Math.floor( ( object_.position.y + object_.height ) / tile_height );
var left = Math.floor( object_.position.x / tile_width );

/* Then use those to get the value of the collision tile under that corner of the object in the map. */
var value = map[ bottom * map.columns + left ];</pre>
			<p>
				Okay, so, value now holds the tile value of the tile under the object's bottom left corner. Not only do you know the value, but you can easily convert the row and column values of bottom and left into physical coordinates for the tile, which is important for resolving collision. Now that you know the location and value of the tile you are colliding with, you're going to have to resolve the collision. To do this we pass the tile value to a collision lookup table and call the corresponding function, passing it the location values like so:
			</p>
			<pre class="Math">/* Get the function in the lookup table and call it, passing the object, left, and bottom as parameters. */
lookup_table[ value ]( object_, left, bottom );</pre>
			<p>
				Inside the lookup table are functions labeled with numbers:
			</p>
			<pre class="Math">var lookup_table = {
	// This particular function doesn't use tile_x_.
	0 : function( object_, tile_x_, tile_y_ ){
		// Calculate the physical top position of the tile for the second parameter.
  		this.collideTop( object_, tile_y_ * tile_height );
            }</pre>
			<p>
				For the sake of simplicity, let's say there's only one function in there labeled with 0. Now the lookup table finds the function that corresponds to the tile value (apparently 0) and calls it with the parameters you passed in. Finally that function calls yet another function, the collideTop function in this case, which looks like this:
			</p>
			<pre class="Math">collideTop : function( object_, top_ ){
	if ( object_.position.y + object_.height > top_ && object_.last_position.y + object_.height <= top_ ){
		object_.last_position.y = object_.position.y = top_ - object_.height;
		object_.velocity.y = 0;
	}
}</pre>
			<p>
				Okay, so those are the three steps to performing collision detection and response using this technique. That will effectively place the red square on top of a platform tile.
			</p>
			<p>
				Now, as for the reason the four sided tiles seem to glitch when they're next to each other, that is because they handle collision on more than one axis. When the red square moves along side them, he will collide with one on the y axis and the other on the x axis, causing him to halt vertically when falling along side vertically stacked solid tiles, and halting him horizontally along horizontally placed tiles. To combat this, you have to avoid placing solid tiles next to each other.
			</p>
			<p>
				The benefit of this approach is that you can stuff the function in the lookup table with a unique function for each one of a tile's sides. Say you want to simulate two solid tiles next to each other horizontally. How do you avoid the hangup when your object moves between them? Instead of two four sided tiles you use two three sided tiles that open into each other, effectively forming a large rectangle. You will see what I mean in later examples, but for now I just wanted to show you some basic implementation. The reason for this is because of how huge the number of collision functions gets for this approach. For this example alone there are 5 functions for the individual tiles and 4 functions that perform the actual collision. The red tile has no function at all. If you were to somehow get into the red tile area on the map, you'd have a real error on your hands.
			</p>
			<p>
				Why would you want all those functions, though: one for each tile? I guess it's up to personal preference, but with this approach you can easily mix and match functions to create unique collision objects. Slopes in particular benefit from this approach. You can make some pretty sweet stuff that conventional methods don't accommodate. So check out the next example! And definitely look at the source code.
			</p>
			<br>
			<a href="../tutorial01/gameloop.html" id="left_link">Game Loop</a>
			<a href="https://github.com/userpoth/userpoth.github.io/tree/master/tilebasedgametutorials/tutorial02" id="center_link">Source</a>
			<a href="" id="right_link">#</a>
		</div>

		<!-- Footer. -->
		<div id="footer">
			<a href="../index.html">Index</a>
		</div>

		<!-- Script. -->
		<script src="collision.js" type="text/javascript"></script>
	</body>
</html>